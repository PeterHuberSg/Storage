//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into DL.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Threading;
using Storage;


namespace StorageModel  {

  /// <summary>
  /// A part of DL is static, which gives easy access to all stored data (=context) through DL.Data. But most functionality is in the
  /// instantiatable part of DL. Since it is instantiatable, is possible to use different contexts over the lifetime of a program. This 
  /// is helpful for unit testing. Use DL.Init() to create a new context and dispose it with DisposeData() before creating a new one.
  /// </summary>
  public partial class DL: IDisposable {

    #region static Part
    //      -----------

    /// <summary>
    /// Provides static root access to the data context
    /// </summary>
    public static DL Data {
      get { return data!; }
    }
    private static DL? data; //data is needed for Interlocked.Exchange(ref data, null) in DisposeData()


    /// <summary>
    /// Constructs the StorageDirectories for all auto generated classes
    /// </summary>
    /// <param name="csvConfig">null: no permanent data storage, not null: info where to store the data</param>
    public static void Init(CsvConfig? csvConfig) {
      if (data!=null) throw new Exception("Dispose old data first before initiating new ones.");

      data = new DL(csvConfig);
    }


    /// <summary>
    /// Flushes all data to permanent storage location if permanent data storage is active. Compacts data storage
    /// by applying all updates and removing all instances marked as deleted if isCompactDuringDispose==true.
    /// </summary>
    public static void DisposeData() {
      var dataLocal = Interlocked.Exchange(ref data, null);
      dataLocal?.Dispose();
    }
    #endregion


    #region Properties
    //      ----------

    /// <summary>
    /// Directory of all DictionaryChildren
    /// </summary>
    public StorageDictionary<DictionaryChild, DL> DictionaryChildren { get; private set; }

    /// <summary>
    /// Directory of all Minimals
    /// </summary>
    public StorageDictionary<Minimal, DL> Minimals { get; private set; }

    /// <summary>
    /// Directory of all MinimalRefs
    /// </summary>
    public StorageDictionary<MinimalRef, DL> MinimalRefs { get; private set; }

    /// <summary>
    /// Directory of all ParentDictionarys
    /// </summary>
    public StorageDictionary<ParentDictionary, DL> ParentDictionarys { get; private set; }

    /// <summary>
    /// Directory of all SampleX
    /// </summary>
    public StorageDictionary<Sample, DL> SampleX { get; private set; }

    /// <summary>
    /// Directory of all SampleDetails
    /// </summary>
    public StorageDictionary<SampleDetail, DL> SampleDetails { get; private set; }

    /// <summary>
    /// Directory of all SampleMasters
    /// </summary>
    public StorageDictionary<SampleMaster, DL> SampleMasters { get; private set; }
    #endregion


    #region Events
    //      ------

    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// Creates a new data context. If csvConfig is null, the data is only stored in RAM, but gets lost once 
    /// program terminates. With csvConfig defined, existing data gets read at startup, changes immediately
    /// when written and Dispose() ensures by flushing that all data is permanently stored.
    /// </summary>
    public DL(CsvConfig? csvConfig) {
      if (csvConfig==null) {
        SampleMasters = new StorageDictionary<SampleMaster, DL>(
          this,
          SampleMaster.SetKey,
          null,
          areInstancesUpdatable: true,
          areInstancesDeletable: false);
        SampleX = new StorageDictionary<Sample, DL>(
          this,
          Sample.SetKey,
          Sample.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true);
        SampleDetails = new StorageDictionary<SampleDetail, DL>(
          this,
          SampleDetail.SetKey,
          SampleDetail.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true);
        Minimals = new StorageDictionary<Minimal, DL>(
          this,
          Minimal.SetKey,
          null,
          areInstancesUpdatable: false,
          areInstancesDeletable: false);
        MinimalRefs = new StorageDictionary<MinimalRef, DL>(
          this,
          MinimalRef.SetKey,
          null,
          areInstancesUpdatable: false,
          areInstancesDeletable: false);
        ParentDictionarys = new StorageDictionary<ParentDictionary, DL>(
          this,
          ParentDictionary.SetKey,
          ParentDictionary.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true);
        DictionaryChildren = new StorageDictionary<DictionaryChild, DL>(
          this,
          DictionaryChild.SetKey,
          DictionaryChild.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true);
      } else {
        SampleMasters = new StorageDictionaryCSV<SampleMaster, DL>(
          this,
          csvConfig!,
          SampleMaster.MaxLineLength,
          SampleMaster.Headers,
          SampleMaster.SetKey,
          SampleMaster.Create,
          null,
          SampleMaster.Update,
          SampleMaster.Write,
          null,
          areInstancesUpdatable: true,
          areInstancesDeletable: false,
          isCompactDuringDispose: false);
        SampleX = new StorageDictionaryCSV<Sample, DL>(
          this,
          csvConfig!,
          Sample.MaxLineLength,
          Sample.Headers,
          Sample.SetKey,
          Sample.Create,
          Sample.Verify,
          Sample.Update,
          Sample.Write,
          Sample.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true,
          isCompactDuringDispose: false);
        SampleDetails = new StorageDictionaryCSV<SampleDetail, DL>(
          this,
          csvConfig!,
          SampleDetail.MaxLineLength,
          SampleDetail.Headers,
          SampleDetail.SetKey,
          SampleDetail.Create,
          SampleDetail.Verify,
          SampleDetail.Update,
          SampleDetail.Write,
          SampleDetail.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true,
          isCompactDuringDispose: false);
        Minimals = new StorageDictionaryCSV<Minimal, DL>(
          this,
          csvConfig!,
          Minimal.MaxLineLength,
          Minimal.Headers,
          Minimal.SetKey,
          Minimal.Create,
          null,
          null,
          Minimal.Write,
          null,
          areInstancesUpdatable: false,
          areInstancesDeletable: false,
          isCompactDuringDispose: true);
        MinimalRefs = new StorageDictionaryCSV<MinimalRef, DL>(
          this,
          csvConfig!,
          MinimalRef.MaxLineLength,
          MinimalRef.Headers,
          MinimalRef.SetKey,
          MinimalRef.Create,
          null,
          null,
          MinimalRef.Write,
          null,
          areInstancesUpdatable: false,
          areInstancesDeletable: false,
          isCompactDuringDispose: true);
        ParentDictionarys = new StorageDictionaryCSV<ParentDictionary, DL>(
          this,
          csvConfig!,
          ParentDictionary.MaxLineLength,
          ParentDictionary.Headers,
          ParentDictionary.SetKey,
          ParentDictionary.Create,
          null,
          ParentDictionary.Update,
          ParentDictionary.Write,
          ParentDictionary.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true,
          isCompactDuringDispose: false);
        DictionaryChildren = new StorageDictionaryCSV<DictionaryChild, DL>(
          this,
          csvConfig!,
          DictionaryChild.MaxLineLength,
          DictionaryChild.Headers,
          DictionaryChild.SetKey,
          DictionaryChild.Create,
          DictionaryChild.Verify,
          DictionaryChild.Update,
          DictionaryChild.Write,
          DictionaryChild.Disconnect,
          areInstancesUpdatable: true,
          areInstancesDeletable: true,
          isCompactDuringDispose: true);
      }
      onConstruct();
    }

    /// <summary>}
    /// Called at end of constructor
    /// </summary>}
    partial void onConstruct();
    #endregion


    #region IDisposable Support
    //      -------------------

    /// <summary>
    /// Is DL.Data already disposed ?
    /// </summary>
    public bool IsDisposed {
      get { return isDisposed==1; }
    }
    int isDisposed = 0;


    protected virtual void Dispose(bool disposing) {
      var wasDisposed = Interlocked.Exchange(ref isDisposed, 1);//prevents that 2 threads dispose simultaneously
      if (wasDisposed==1) return; // already disposed

      if (disposing) {
        onDispose();
        DictionaryChildren.Dispose();
        ParentDictionarys.Dispose();
        MinimalRefs.Dispose();
        Minimals.Dispose();
        SampleDetails.Dispose();
        SampleX.Dispose();
        SampleMasters.Dispose();
        data = null;
      }
    }

    /// <summary>}
    /// Called before storageDirectories get disposed.
    /// </summary>}
    partial void onDispose();


    public void Dispose() {
      Dispose(true);
    }
    #endregion


    #region Methods
    //      -------

    #endregion

  }
}

