//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by StorageClassGenerator
//
//     Do not change code in this file, it will get lost when the file gets 
//     auto generated again. Write your code into ReadOnlyParentUpdatableChild_Child.cs.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using System;
using System.Collections.Generic;
using System.Threading;
using Storage;


namespace StorageModel  {


    /// <summary>
    /// Example of a "readonly" Child, i.e. the child's properties will not change and once it is added to its parent
    /// and therefore it also cannot be removed from parent, because the Parent property of the child cannot be changed
    /// either.
    /// </summary>
  public partial class ReadOnlyParentUpdatableChild_Child: IStorage<ReadOnlyParentUpdatableChild_Child> {

    #region Properties
    //      ----------

    /// <summary>
    /// Unique identifier for ReadOnlyParentUpdatableChild_Child. Gets set once ReadOnlyParentUpdatableChild_Child gets added to DC.Data.
    /// </summary>
    public int Key { get; private set; }
    internal static void SetKey(ReadOnlyParentUpdatableChild_Child readOnlyParentUpdatableChild_Child, int key) { readOnlyParentUpdatableChild_Child.Key = key; }


    /// <summary>
    /// Readonly Text, because class is not updatable
    /// </summary>
    public string Text { get; private set; }


    /// <summary>
    /// Parent
    /// </summary>
    public ReadOnlyParentUpdatableChild_Parent Parent { get; private set; }


    /// <summary>
    /// Parent
    /// </summary>          
    public ReadOnlyParentUpdatableChild_ParentNullable? ParentNullable { get; private set; }


    /// <summary>
    /// Headers written to first line in CSV file
    /// </summary>
    internal static readonly string[] Headers = {"Key", "Text", "Parent", "ParentNullable"};


    /// <summary>
    /// None existing ReadOnlyParentUpdatableChild_Child
    /// </summary>
    internal static ReadOnlyParentUpdatableChild_Child NoReadOnlyParentUpdatableChild_Child = new ReadOnlyParentUpdatableChild_Child("NoText", ReadOnlyParentUpdatableChild_Parent.NoReadOnlyParentUpdatableChild_Parent, null, isStoring: false);
    #endregion


    #region Events
    //      ------

    /// <summary>
    /// Content of ReadOnlyParentUpdatableChild_Child has changed. Gets only raised for changes occurring after loading DC.Data with previously stored data.
    /// </summary>
    public event Action<ReadOnlyParentUpdatableChild_Child>? HasChanged;
    #endregion


    #region Constructors
    //      ------------

    /// <summary>
    /// ReadOnlyParentUpdatableChild_Child Constructor. If isStoring is true, adds ReadOnlyParentUpdatableChild_Child to DC.Data.ReadOnlyParentUpdatableChild_Children, 
    /// adds ReadOnlyParentUpdatableChild_Child to readOnlyParentUpdatableChild_Parent.ReadOnlyParentUpdatableChild_Children
    /// and if there is a ParentNullable adds ReadOnlyParentUpdatableChild_Child to readOnlyParentUpdatableChild_ParentNullable.ReadOnlyParentUpdatableChild_Children.
    /// </summary>
    public ReadOnlyParentUpdatableChild_Child(string text, ReadOnlyParentUpdatableChild_Parent parent, ReadOnlyParentUpdatableChild_ParentNullable? parentNullable, bool isStoring = true) {
      Key = StorageExtensions.NoKey;
      Text = text;
      Parent = parent;
      ParentNullable = parentNullable;
      onConstruct();

      if (isStoring) {
        Store();
      }
    }
    partial void onConstruct();


    /// <summary>
    /// Constructor for ReadOnlyParentUpdatableChild_Child read from CSV file
    /// </summary>
    private ReadOnlyParentUpdatableChild_Child(int key, CsvReader csvReader, DC context) {
      Key = key;
      Text = csvReader.ReadString();
      var readOnlyParentUpdatableChild_ParentKey = csvReader.ReadInt();
      if (context.ReadOnlyParentUpdatableChild_Parents.TryGetValue(readOnlyParentUpdatableChild_ParentKey, out var parent)) {
          Parent = parent;
      } else {
        throw new Exception($"Read ReadOnlyParentUpdatableChild_Child from CSV file: Cannot find Parent with key {readOnlyParentUpdatableChild_ParentKey}." + Environment.NewLine + 
          csvReader.PresentContent);
      }
      var parentNullableKey = csvReader.ReadIntNull();
      if (parentNullableKey.HasValue) {
        if (context.ReadOnlyParentUpdatableChild_ParentNullables.TryGetValue(parentNullableKey.Value, out var parentNullable)) {
          ParentNullable = parentNullable;
        } else {
          ParentNullable = ReadOnlyParentUpdatableChild_ParentNullable.NoReadOnlyParentUpdatableChild_ParentNullable;
        }
      }
      if (Parent!=ReadOnlyParentUpdatableChild_Parent.NoReadOnlyParentUpdatableChild_Parent) {
        Parent.AddToReadOnlyParentUpdatableChild_Children(this);
      }
      if (parentNullableKey.HasValue && ParentNullable!=ReadOnlyParentUpdatableChild_ParentNullable.NoReadOnlyParentUpdatableChild_ParentNullable) {
        ParentNullable!.AddToReadOnlyParentUpdatableChild_Children(this);
      }
      onCsvConstruct(context);
    }
    partial void onCsvConstruct(DC context);


    /// <summary>
    /// New ReadOnlyParentUpdatableChild_Child read from CSV file
    /// </summary>
    internal static ReadOnlyParentUpdatableChild_Child Create(int key, CsvReader csvReader, DC context) {
      return new ReadOnlyParentUpdatableChild_Child(key, csvReader, context);
    }


    /// <summary>
    /// Verify that readOnlyParentUpdatableChild_Child.Parent exists.
    /// Verify that readOnlyParentUpdatableChild_Child.ParentNullable exists.
    /// </summary>
    internal static bool Verify(ReadOnlyParentUpdatableChild_Child readOnlyParentUpdatableChild_Child) {
      if (readOnlyParentUpdatableChild_Child.Parent==ReadOnlyParentUpdatableChild_Parent.NoReadOnlyParentUpdatableChild_Parent) return false;
      if (readOnlyParentUpdatableChild_Child.ParentNullable==ReadOnlyParentUpdatableChild_ParentNullable.NoReadOnlyParentUpdatableChild_ParentNullable) return false;
      return true;
    }
    #endregion


    #region Methods
    //      -------

    /// <summary>
    /// Adds ReadOnlyParentUpdatableChild_Child to DC.Data.ReadOnlyParentUpdatableChild_Children, ReadOnlyParentUpdatableChild_Parent and ReadOnlyParentUpdatableChild_ParentNullable. 
    /// </summary>
    public void Store() {
      if (Key>=0) {
        throw new Exception($"ReadOnlyParentUpdatableChild_Child cannot be stored again in DC.Data, key is {Key} greater equal 0." + Environment.NewLine + ToString());
      }
      if (Parent.Key<0) {
        throw new Exception($"ReadOnlyParentUpdatableChild_Child cannot be stored in DC.Data, Parent is missing or not stored yet." + Environment.NewLine + ToString());
      }
      if (ParentNullable!=null && ParentNullable.Key<0) {
        throw new Exception($"ReadOnlyParentUpdatableChild_Child cannot be stored in DC.Data, ParentNullable is not stored yet." + Environment.NewLine + ToString());
      }
      onStore();
      DC.Data.ReadOnlyParentUpdatableChild_Children.Add(this);
      Parent.AddToReadOnlyParentUpdatableChild_Children(this);
      ParentNullable?.AddToReadOnlyParentUpdatableChild_Children(this);
    }
    partial void onStore();


    /// <summary>
    /// Maximal number of UTF8 characters needed to write ReadOnlyParentUpdatableChild_Child to CSV file
    /// </summary>
    public const int MaxLineLength = 150;


    /// <summary>
    /// Write ReadOnlyParentUpdatableChild_Child to CSV file
    /// </summary>
    internal static void Write(ReadOnlyParentUpdatableChild_Child readOnlyParentUpdatableChild_Child, CsvWriter csvWriter) {
      readOnlyParentUpdatableChild_Child.onCsvWrite();
      csvWriter.Write(readOnlyParentUpdatableChild_Child.Text);
      if (readOnlyParentUpdatableChild_Child.Parent.Key<0) throw new Exception($"Cannot write readOnlyParentUpdatableChild_Child '{readOnlyParentUpdatableChild_Child}' to CSV File, because Parent is not stored in DC.Data.ReadOnlyParentUpdatableChild_Parents.");

      csvWriter.Write(readOnlyParentUpdatableChild_Child.Parent.Key.ToString());
      if (readOnlyParentUpdatableChild_Child.ParentNullable is null) {
        csvWriter.WriteNull();
      } else {
        if (readOnlyParentUpdatableChild_Child.ParentNullable.Key<0) throw new Exception($"Cannot write readOnlyParentUpdatableChild_Child '{readOnlyParentUpdatableChild_Child}' to CSV File, because ParentNullable is not stored in DC.Data.ReadOnlyParentUpdatableChild_ParentNullables.");

        csvWriter.Write(readOnlyParentUpdatableChild_Child.ParentNullable.Key.ToString());
      }
    }
    partial void onCsvWrite();


    /// <summary>
    /// Updates ReadOnlyParentUpdatableChild_Child with the provided values
    /// </summary>
    public void Update(string text, ReadOnlyParentUpdatableChild_Parent parent, ReadOnlyParentUpdatableChild_ParentNullable? parentNullable) {
      var isCancelled = false;
      onUpdating(text, parent, parentNullable, ref isCancelled);
      if (isCancelled) return;

      var isChangeDetected = false;
      if (Text!=text) {
        Text = text;
        isChangeDetected = true;
      }
      if (Parent!=parent) {
        Parent.RemoveFromReadOnlyParentUpdatableChild_Children(this);
        Parent = parent;
        Parent.AddToReadOnlyParentUpdatableChild_Children(this);
        isChangeDetected = true;
      }
      if (ParentNullable is null) {
        if (parentNullable is null) {
          //nothing to do
        } else {
          ParentNullable = parentNullable;
          ParentNullable.AddToReadOnlyParentUpdatableChild_Children(this);
          isChangeDetected = true;
        }
      } else {
        if (parentNullable is null) {
          ParentNullable.RemoveFromReadOnlyParentUpdatableChild_Children(this);
          ParentNullable = null;
          isChangeDetected = true;
        } else {
          if (ParentNullable!=parentNullable) {
            ParentNullable.RemoveFromReadOnlyParentUpdatableChild_Children(this);
            ParentNullable = parentNullable;
            ParentNullable.AddToReadOnlyParentUpdatableChild_Children(this);
            isChangeDetected = true;
          }
        }
      }
      if (isChangeDetected) {
        onUpdated();
        HasChanged?.Invoke(this);
      }
    }
    partial void onUpdating(string text, ReadOnlyParentUpdatableChild_Parent parent, ReadOnlyParentUpdatableChild_ParentNullable? parentNullable, ref bool isCancelled);
    partial void onUpdated();


    /// <summary>
    /// Updates this ReadOnlyParentUpdatableChild_Child with values from CSV file
    /// </summary>
    internal static void Update(ReadOnlyParentUpdatableChild_Child readOnlyParentUpdatableChild_Child, CsvReader csvReader, DC context) {
      readOnlyParentUpdatableChild_Child.Text = csvReader.ReadString();
      if (!context.ReadOnlyParentUpdatableChild_Parents.TryGetValue(csvReader.ReadInt(), out var parent)) {
        parent = ReadOnlyParentUpdatableChild_Parent.NoReadOnlyParentUpdatableChild_Parent;
      }
      if (readOnlyParentUpdatableChild_Child.Parent!=parent) {
        if (readOnlyParentUpdatableChild_Child.Parent!=ReadOnlyParentUpdatableChild_Parent.NoReadOnlyParentUpdatableChild_Parent) {
          readOnlyParentUpdatableChild_Child.Parent.RemoveFromReadOnlyParentUpdatableChild_Children(readOnlyParentUpdatableChild_Child);
        }
        readOnlyParentUpdatableChild_Child.Parent = parent;
        readOnlyParentUpdatableChild_Child.Parent.AddToReadOnlyParentUpdatableChild_Children(readOnlyParentUpdatableChild_Child);
      }
      var parentNullableKey = csvReader.ReadIntNull();
      ReadOnlyParentUpdatableChild_ParentNullable? parentNullable;
      if (parentNullableKey is null) {
        parentNullable = null;
      } else {
        if (!context.ReadOnlyParentUpdatableChild_ParentNullables.TryGetValue(parentNullableKey.Value, out parentNullable)) {
          parentNullable = ReadOnlyParentUpdatableChild_ParentNullable.NoReadOnlyParentUpdatableChild_ParentNullable;
        }
      }
      if (readOnlyParentUpdatableChild_Child.ParentNullable is null) {
        if (parentNullable is null) {
          //nothing to do
        } else {
          readOnlyParentUpdatableChild_Child.ParentNullable = parentNullable;
          readOnlyParentUpdatableChild_Child.ParentNullable.AddToReadOnlyParentUpdatableChild_Children(readOnlyParentUpdatableChild_Child);
        }
      } else {
        if (parentNullable is null) {
          if (readOnlyParentUpdatableChild_Child.ParentNullable!=ReadOnlyParentUpdatableChild_ParentNullable.NoReadOnlyParentUpdatableChild_ParentNullable) {
            readOnlyParentUpdatableChild_Child.ParentNullable.RemoveFromReadOnlyParentUpdatableChild_Children(readOnlyParentUpdatableChild_Child);
          }
          readOnlyParentUpdatableChild_Child.ParentNullable = null;
        } else {
          if (readOnlyParentUpdatableChild_Child.ParentNullable!=ReadOnlyParentUpdatableChild_ParentNullable.NoReadOnlyParentUpdatableChild_ParentNullable) {
            readOnlyParentUpdatableChild_Child.ParentNullable.RemoveFromReadOnlyParentUpdatableChild_Children(readOnlyParentUpdatableChild_Child);
          }
          readOnlyParentUpdatableChild_Child.ParentNullable = parentNullable;
          readOnlyParentUpdatableChild_Child.ParentNullable.AddToReadOnlyParentUpdatableChild_Children(readOnlyParentUpdatableChild_Child);
        }
      }
      readOnlyParentUpdatableChild_Child.onCsvUpdate();
    }
    partial void onCsvUpdate();


    /// <summary>
    /// Removing ReadOnlyParentUpdatableChild_Child from DC.Data.ReadOnlyParentUpdatableChild_Children is not supported.
    /// </summary>
    public void Remove() {
      throw new NotSupportedException("StorageClass attribute AreInstancesDeletable is false.");
    }


    /// <summary>
    /// Returns property values
    /// </summary>
    public string ToShortString() {
      var returnString =
        $"{Key.ToKeyString()}," +
        $" {Text}," +
        $" {Parent.ToShortString()}," +
        $" {ParentNullable?.ToShortString()}";
      onToShortString(ref returnString);
      return returnString;
    }
    partial void onToShortString(ref string returnString);


    /// <summary>
    /// Returns all property names and values
    /// </summary>
    public override string ToString() {
      var returnString =
        $"Key: {Key}," +
        $" Text: {Text}," +
        $" Parent: {Parent.ToShortString()}," +
        $" ParentNullable: {ParentNullable?.ToShortString()};";
      onToString(ref returnString);
      return returnString;
    }
    partial void onToString(ref string returnString);
    #endregion
  }


  #region ReadOnlyParentUpdatableChild_ChildWriter
  //      ----------------------------------------

  /// <summary>
  /// Writes a CSV file containing records which can be read back as ReadOnlyParentUpdatableChild_Child. Note that the keys of linked objects
  /// need to be provided in Write(), since the data context will not be involved.
  /// </summary>
  public class ReadOnlyParentUpdatableChild_ChildWriter: IDisposable {

    readonly CsvConfig csvConfig;
    readonly CsvWriter csvWriter;
    int lastKey = int.MinValue;


    /// <summary>
    /// Constructor, will write the ReadOnlyParentUpdatableChild_Child header line into the CSV file. Dispose ReadOnlyParentUpdatableChild_ChildWriter once done.
    /// </summary>
    public ReadOnlyParentUpdatableChild_ChildWriter(string? fileNamePath, CsvConfig csvConfig, int maxLineCharLenght) {
      this.csvConfig = csvConfig;
      csvWriter = new CsvWriter(fileNamePath, csvConfig, maxLineCharLenght, null, 0);
      var csvHeaderString = Csv.ToCsvHeaderString(ReadOnlyParentUpdatableChild_Child.Headers, csvConfig.Delimiter);
      csvWriter.WriteLine(csvHeaderString);
    }


    /// <summary>
    /// Writes the details of one ReadOnlyParentUpdatableChild_Child to the CSV file
    /// </summary>
    public void Write(int key, string text, int parentKey, int? parentNullableKey) {
      if (key<0) {
        throw new Exception($"ReadOnlyParentUpdatableChild_Child's key {key} needs to be greater equal 0.");
      }
      if (key<=lastKey) {
        throw new Exception($"ReadOnlyParentUpdatableChild_Child's key {key} must be greater than the last written ReadOnlyParentUpdatableChild_Child's key {lastKey}.");
      }
      lastKey = key;
      csvWriter.WriteFirstLineChar(csvConfig.LineCharAdd);
      csvWriter.Write(key);
      csvWriter.Write(text);
      if (parentKey<0) throw new Exception($"Cannot write readOnlyParentUpdatableChild_Child to CSV File, because Parent is not stored in DC.Data.ReadOnlyParentUpdatableChild_Parents.");

      csvWriter.Write(parentKey.ToString());
      if (parentNullableKey is null) {
        csvWriter.WriteNull();
      } else {
        if (parentNullableKey<0) throw new Exception($"Cannot write readOnlyParentUpdatableChild_Child to CSV File, because ParentNullable is not stored in DC.Data.ReadOnlyParentUpdatableChild_ParentNullables.");

        csvWriter.Write(parentNullableKey.ToString());
      }
      csvWriter.WriteEndOfLine();
    }


    #region IDisposable Support
    //      -------------------

    /// <summary>
    /// Executes disposal of ReadOnlyParentUpdatableChild_ChildWriter exactly once.
    /// </summary>
    public void Dispose() {
      Dispose(true);

      GC.SuppressFinalize(this);
    }


    /// <summary>
    /// Is ReadOnlyParentUpdatableChild_ChildWriter already exposed ?
    /// </summary>
    protected bool IsDisposed {
      get { return isDisposed==1; }
    }


    int isDisposed = 0;


    /// <summary>
    /// Inheritors should call Dispose(false) from their destructor
    /// </summary>
    protected void Dispose(bool disposing) {
      var wasDisposed = Interlocked.Exchange(ref isDisposed, 1);//prevents that 2 threads dispose simultaneously
      if (wasDisposed==1) return; // already disposed

      csvWriter.Dispose();
    }
    #endregion
  }
  #endregion
}
